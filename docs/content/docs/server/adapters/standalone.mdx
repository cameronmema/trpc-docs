---
title: Standalone Adapter
description: Simple Node.js HTTP server for tRPC development and deployment
icon: IconServer
---

The Standalone adapter is the simplest way to get a tRPC server running. It's built on top of the standard Node.js HTTP server and is perfect for local development, simple deployments, and getting started quickly.

<Callout title="Best for Getting Started">
  The standalone adapter requires no additional dependencies and is ideal for
  prototyping, learning tRPC, and simple production deployments.
</Callout>

## Example Apps

<Cards>
  <Card
    href="https://github.com/trpc/trpc/tree/main/examples/minimal"
    title="Minimal Standalone Server"
  >
    Basic standalone tRPC server with simple procedures
  </Card>
  <Card
    href="https://stackblitz.com/github/trpc/trpc/tree/main/examples/minimal"
    title="StackBlitz Demo"
  >
    Try the minimal server example in your browser
  </Card>
  <Card
    href="https://github.com/trpc/trpc/tree/main/examples/minimal-react"
    title="Standalone with CORS"
  >
    Standalone server with CORS configuration for React frontend
  </Card>
  <Card
    href="https://stackblitz.com/github/trpc/trpc/tree/main/examples/minimal-react"
    title="React Demo"
  >
    Full-stack example with React client
  </Card>
</Cards>

## Installation

Install the core tRPC server package:

<Tabs items={['npm', 'pnpm', 'yarn', 'bun']}>
  <Tab value="npm">```bash npm install @trpc/server ```</Tab>
  <Tab value="pnpm">```bash pnpm add @trpc/server ```</Tab>
  <Tab value="yarn">```bash yarn add @trpc/server ```</Tab>
  <Tab value="bun">```bash bun add @trpc/server ```</Tab>
</Tabs>

<Callout title="No Additional Dependencies" type="success">
  The standalone adapter doesn't require any additional web framework
  dependencies - it uses Node.js built-in HTTP server.
</Callout>

## Quick Start

### 1. Create your tRPC router

Define your API procedures:

```typescript title="router.ts"
import { initTRPC } from '@trpc/server';
import { z } from 'zod';

export const t = initTRPC.create();

export const appRouter = t.router({
  getUser: t.procedure
    .input(z.string())
    .query(({ input }) => {
      return { id: input, name: 'Bilbo' };
    }),

  createUser: t.procedure
    .input(z.object({
      name: z.string().min(5),
      email: z.string().email().optional(),
    }))
    .mutation(async ({ input }) => {
      // Use your ORM of choice
      return await UserModel.create({
        data: input,
      });
    }),
});

// Export type definition of API
export type AppRouter = typeof appRouter;
```

### 2. Create standalone server

```typescript title="server.ts"
import { createHTTPServer } from '@trpc/server/adapters/standalone';
import { appRouter } from './router';

const server = createHTTPServer({
  router: appRouter,
  createContext() {
    console.log('Request received');
    return {};
  },
});

const port = 2022;
server.listen(port);
console.log(`Server running on http://localhost:${port}`);
```

That's it! Your tRPC server is now running and ready to handle requests.

## API Endpoints

Your tRPC procedures are available as HTTP endpoints:

| Procedure    | HTTP Method | Endpoint               | Description                              |
| ------------ | ----------- | ---------------------- | ---------------------------------------- |
| `getUser`    | GET         | `/getUser?input=INPUT` | Where INPUT is a URI-encoded JSON string |
| `createUser` | POST        | `/createUser`          | With JSON body containing the input data |

### Example requests

<Tabs items={['Query Example', 'Mutation Example']}>
  <Tab value="Query Example">
    ```bash
    # GET request for queries
    curl "http://localhost:2022/getUser?input=\"user_123\""
    ```
    
    Response:
    ```json
    {
      "result": {
        "data": {
          "id": "user_123",
          "name": "Bilbo"
        }
      }
    }
    ```
  </Tab>
  <Tab value="Mutation Example">
    ```bash
    # POST request for mutations
    curl -X POST http://localhost:2022/createUser \
      -H "Content-Type: application/json" \
      -d '{"name": "Frodo Baggins", "email": "frodo@shire.com"}'
    ```
    
    Response:
    ```json
    {
      "result": {
        "data": {
          "id": "generated_id",
          "name": "Frodo Baggins",
          "email": "frodo@shire.com"
        }
      }
    }
    ```
  </Tab>
</Tabs>

## Configuration Options

### Basic Configuration

```typescript title="server.ts"
import { createHTTPServer } from '@trpc/server/adapters/standalone';
import { appRouter } from './router';

const server = createHTTPServer({
  router: appRouter,
  createContext() {
    return {
      // Add your context here
      startTime: Date.now(),
    };
  },
  // Optional: Set a custom base path
  basePath: '/trpc/', // defaults to '/'
});

server.listen(3000);
```

### With Context

Add request-scoped data to all procedures:

```typescript title="server.ts"
import { createHTTPServer } from '@trpc/server/adapters/standalone';
import type { CreateHTTPContextOptions } from '@trpc/server/adapters/standalone';

export function createContext(opts: CreateHTTPContextOptions) {
  return {
    req: opts.req,
    res: opts.res,
    info: opts.info,
    // Add database, user session, etc.
    db: myDatabase,
    currentUser: null, // Will be set by auth middleware
  };
}

const server = createHTTPServer({
  router: appRouter,
  createContext,
});
```

### Error Handling

Add global error handling:

```typescript title="server.ts"
const server = createHTTPServer({
  router: appRouter,
  createContext,
  onError: ({ error, path, input, ctx, type }) => {
    console.error(`Error in ${type} procedure on path '${path}':`, error);

    // Send to error monitoring
    if (error.code === 'INTERNAL_SERVER_ERROR') {
      errorService.captureException(error, {
        extra: { path, input, type },
      });
    }
  },
});
```

## CORS Support

For cross-origin requests, you'll need to handle CORS manually:

### Option 1: Using the `cors` package

```bash
npm install cors @types/cors
```

```typescript title="server.ts"
import { createHTTPServer } from '@trpc/server/adapters/standalone';
import cors from 'cors';

const server = createHTTPServer({
  middleware: cors(), // Simple CORS for all requests
  router: appRouter,
  createContext() {
    return {};
  },
});

server.listen(3000);
```

### Option 2: Custom CORS middleware

```typescript title="server.ts"
import { createHTTPServer } from '@trpc/server/adapters/standalone';

const corsMiddleware = (req, res, next) => {
  // Set CORS headers
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type');

  // Handle preflight OPTIONS request
  if (req.method === 'OPTIONS') {
    res.writeHead(200);
    res.end();
    return;
  }

  next();
};

const server = createHTTPServer({
  middleware: corsMiddleware,
  router: appRouter,
  createContext() {
    return {};
  },
});
```

### Option 3: Specific CORS configuration

```typescript title="server.ts"
import cors from 'cors';

const server = createHTTPServer({
  middleware: cors({
    origin: process.env.NODE_ENV === 'production'
      ? ['https://yourdomain.com']
      : ['http://localhost:3000'],
    credentials: true,
    methods: ['GET', 'POST'],
    allowedHeaders: ['Content-Type', 'Authorization'],
  }),
  router: appRouter,
  createContext() {
    return {};
  },
});
```

## Advanced Usage

### Custom HTTP Server

For more control, use the `createHTTPHandler` to create your own HTTP server:

```typescript title="server.ts"
import { createServer } from 'http';
import { createHTTPHandler } from '@trpc/server/adapters/standalone';

const handler = createHTTPHandler({
  router: appRouter,
  createContext() {
    return {};
  },
});

const server = createServer((req, res) => {
  // Custom request processing
  console.log(`${req.method} ${req.url}`);

  // Add custom headers
  res.setHeader('X-Powered-By', 'tRPC');

  // Call tRPC handler
  handler(req, res);
});

server.listen(3001);
console.log('Custom server running on http://localhost:3001');
```

### Custom Base Path

Handle requests under a specific path:

```typescript title="server.ts"
import { createServer } from 'http';
import { createHTTPHandler } from '@trpc/server/adapters/standalone';

const handler = createHTTPHandler({
  router: appRouter,
  basePath: '/api/trpc/', // Slice this from the beginning of request path
});

const server = createServer((req, res) => {
  if (req.url?.startsWith('/api/trpc/')) {
    return handler(req, res);
  }

  // Handle other routes
  if (req.url === '/health') {
    res.writeHead(200, { 'Content-Type': 'application/json' });
    res.end(JSON.stringify({ status: 'ok' }));
    return;
  }

  // 404 for other routes
  res.writeHead(404);
  res.end('Not Found');
});

server.listen(3001);
```

### Multiple Route Handlers

Combine tRPC with other route handlers:

```typescript title="server.ts"
import { createServer } from 'http';
import { createHTTPHandler } from '@trpc/server/adapters/standalone';
import { parse } from 'url';

const trpcHandler = createHTTPHandler({
  router: appRouter,
  createContext() {
    return {};
  },
});

const server = createServer((req, res) => {
  const { pathname } = parse(req.url || '', true);

  // Route to different handlers
  if (pathname?.startsWith('/trpc')) {
    return trpcHandler(req, res);
  }

  if (pathname === '/health') {
    res.writeHead(200, { 'Content-Type': 'application/json' });
    res.end(JSON.stringify({
      status: 'ok',
      timestamp: new Date().toISOString()
    }));
    return;
  }

  if (pathname === '/') {
    res.writeHead(200, { 'Content-Type': 'text/html' });
    res.end('<h1>tRPC Server</h1><p>API available at /trpc</p>');
    return;
  }

  // 404 for unknown routes
  res.writeHead(404);
  res.end('Not Found');
});

server.listen(3000);
```

## HTTP/2 Support

The standalone adapter also supports HTTP/2:

```typescript title="http2-server.ts"
import http2 from 'http2';
import { createHTTP2Handler } from '@trpc/server/adapters/standalone';
import type { CreateHTTP2ContextOptions } from '@trpc/server/adapters/standalone';

export async function createContext(opts: CreateHTTP2ContextOptions) {
  return {
    req: opts.req,   // HTTP/2 ServerHttp2Stream
    res: opts.res,   // HTTP/2 ServerHttp2Stream
    info: opts.info, // Additional connection info
  };
}

const handler = createHTTP2Handler({
  router: appRouter,
  createContext,
});

const server = http2.createSecureServer(
  {
    key: fs.readFileSync('path/to/private-key.pem'),
    cert: fs.readFileSync('path/to/certificate.pem'),
  },
  (req, res) => {
    handler(req, res);
  },
);

server.listen(3001);
console.log('HTTP/2 server running on https://localhost:3001');
```

## Development Patterns

### Environment-Based Configuration

```typescript title="config.ts"
export const config = {
  port: parseInt(process.env.PORT || '3000'),
  host: process.env.HOST || 'localhost',
  cors: {
    enabled: process.env.CORS_ENABLED === 'true',
    origin: process.env.CORS_ORIGIN?.split(',') || ['http://localhost:3000'],
  },
  database: {
    url: process.env.DATABASE_URL,
  },
};
```

```typescript title="server.ts"
import { config } from './config';

const server = createHTTPServer({
  middleware: config.cors.enabled ? cors({ origin: config.cors.origin }) : undefined,
  router: appRouter,
  createContext() {
    return {
      db: createDatabaseConnection(config.database.url),
    };
  },
});

server.listen(config.port, config.host);
console.log(`Server running on http://${config.host}:${config.port}`);
```

### Multiple Environments

Use different configurations for development and production:

```typescript title="server.ts"
import { createHTTPServer } from '@trpc/server/adapters/standalone';

const isDev = process.env.NODE_ENV !== 'production';

const server = createHTTPServer({
  middleware: isDev ? cors() : undefined, // CORS only in development
  router: appRouter,
  createContext() {
    return {};
  },
  onError: isDev
    ? ({ error, path }) => {
        console.error(`❌ Error on path '${path}':`, error);
      }
    : ({ error, path }) => {
        // Production error logging
        errorService.captureException(error, { extra: { path } });
      },
});

server.listen(isDev ? 3000 : process.env.PORT || 8080);
```

## Testing

Test your standalone tRPC server:

```typescript title="server.test.ts"
import { createHTTPHandler } from '@trpc/server/adapters/standalone';
import { appRouter } from './router';
import request from 'supertest';
import { createServer } from 'http';

describe('Standalone tRPC Server', () => {
  let server: ReturnType<typeof createServer>;

  beforeAll(() => {
    const handler = createHTTPHandler({
      router: appRouter,
      createContext: () => ({}),
    });

    server = createServer(handler);
  });

  afterAll(() => {
    server.close();
  });

  it('should handle queries', async () => {
    const response = await request(server)
      .get('/getUser?input="user_123"')
      .expect(200);

    expect(response.body.result.data).toEqual({
      id: 'user_123',
      name: 'Bilbo'
    });
  });

  it('should handle mutations', async () => {
    const response = await request(server)
      .post('/createUser')
      .send({ name: 'Test User', email: 'test@example.com' })
      .expect(200);

    expect(response.body.result.data.name).toBe('Test User');
  });
});
```

## Deployment

### Production Considerations

<Accordions>
  <Accordion title="Process Management">
    Use PM2 or similar for production deployment:
    
    ```json title="ecosystem.config.js"
    module.exports = {
      apps: [{
        name: 'trpc-standalone-server',
        script: './dist/server.js',
        instances: 'max',
        exec_mode: 'cluster',
        env: {
          NODE_ENV: 'production',
          PORT: 3000
        },
        error_file: './logs/err.log',
        out_file: './logs/out.log',
        log_file: './logs/combined.log',
      }]
    };
    ```
  </Accordion>
  
  <Accordion title="Docker Deployment">
    ```dockerfile title="Dockerfile"
    FROM node:18-alpine
    
    WORKDIR /app
    
    COPY package*.json ./
    RUN npm ci --only=production
    
    COPY . .
    RUN npm run build
    
    EXPOSE 3000
    
    CMD ["node", "dist/server.js"]
    ```
  </Accordion>
  
  <Accordion title="Reverse Proxy">
    Use nginx as a reverse proxy for production:
    
    ```nginx title="nginx.conf"
    server {
        listen 80;
        server_name yourdomain.com;
        
        location /api/ {
            proxy_pass http://localhost:3000/;
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection 'upgrade';
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_cache_bypass $http_upgrade;
        }
    }
    ```
  </Accordion>
</Accordions>

## When to Use Standalone

<Callout title="Perfect For">
  - **Learning tRPC**: No framework overhead, simple setup - **Prototyping**:
  Quick API development and testing - **Microservices**: Simple, focused API
  services - **Development**: Local development without additional dependencies
  - **Simple Production**: Basic production deployments
</Callout>

<Callout title="Consider Alternatives When" type="warn">
  - You need advanced middleware features (use Express/Fastify) - You want
  WebSocket support out of the box (use Fastify) - You're building a full-stack
  app (use Next.js) - You need edge runtime deployment (use Fetch adapter)
</Callout>

## Next Steps

<Cards>
  <Card href="/docs/server/procedures" title="Define Procedures">
    Learn how to create queries, mutations, and subscriptions
  </Card>
  <Card href="/docs/server/context" title="Add Context">
    Share data like database connections and user sessions
  </Card>
  <Card href="/docs/server/middlewares" title="Add Middleware">
    Implement authentication, logging, and custom logic
  </Card>
  <Card href="/docs/client" title="Connect Your Frontend">
    Integrate tRPC with your React, Next.js, or other frontend
  </Card>
</Cards>
