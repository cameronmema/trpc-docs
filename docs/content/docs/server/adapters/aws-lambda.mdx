---
title: AWS Lambda Adapter
description: Deploy tRPC on AWS Lambda with API Gateway and Lambda Function URLs
icon: IconCloud
---

The AWS Lambda adapter enables you to run tRPC on AWS serverless infrastructure, supporting API Gateway REST API (v1), HTTP API (v2), and Lambda Function URLs. Perfect for serverless deployments with automatic scaling.

<Callout title="Serverless at Scale">
  AWS Lambda provides automatic scaling, pay-per-use pricing, and seamless
  integration with the AWS ecosystem.
</Callout>

## Example Apps

<Cards>
  <Card
    href="https://github.com/trpc/trpc/tree/main/examples/lambda-api-gateway"
    title="API Gateway Example"
  >
    Complete Lambda setup with API Gateway integration and Node.js client
  </Card>
  <Card
    href="https://github.com/trpc/trpc/tree/main/examples/lambda-url"
    title="Lambda Function URL Example"
  >
    Lambda Function URL implementation with response streaming support
  </Card>
</Cards>

## Installation

Install the required dependencies:

<Tabs items={['npm', 'pnpm', 'yarn', 'bun']}>
  <Tab value="npm">
    ```bash npm install @trpc/server npm install -D @types/aws-lambda ```
  </Tab>
  <Tab value="pnpm">
    ```bash pnpm add @trpc/server pnpm add -D @types/aws-lambda ```
  </Tab>
  <Tab value="yarn">
    ```bash yarn add @trpc/server yarn add -D @types/aws-lambda ```
  </Tab>
  <Tab value="bun">
    ```bash bun add @trpc/server bun add -D @types/aws-lambda ```
  </Tab>
</Tabs>

## API Gateway Integration

### 1. Create your tRPC router

```typescript title="server.ts"
import { initTRPC } from '@trpc/server';
import { z } from 'zod';

export const t = initTRPC.create();

const appRouter = t.router({
  getUser: t.procedure
    .input(z.string())
    .query(({ input }) => {
      return { id: input, name: 'Bilbo' };
    }),

  createUser: t.procedure
    .input(z.object({
      name: z.string().min(2),
      email: z.string().email(),
    }))
    .mutation(async ({ input }) => {
      // Use your database of choice
      return await UserModel.create(input);
    }),
});

// Export type definition of API
export type AppRouter = typeof appRouter;
```

### 2. Set up the Lambda handler

<Tabs items={['API Gateway v2', 'API Gateway v1']}>
  <Tab value="API Gateway v2">
    ```typescript title="lambda.ts"
    import { 
      CreateAWSLambdaContextOptions, 
      awsLambdaRequestHandler 
    } from '@trpc/server/adapters/aws-lambda';
    import type { APIGatewayProxyEventV2 } from 'aws-lambda';
    import { appRouter } from './server';

    // Create context for each request
    const createContext = ({
      event,
      context,
    }: CreateAWSLambdaContextOptions<APIGatewayProxyEventV2>) => ({
      event,
      context,
      // Add your context here - database connections, user info, etc.
    });

    type Context = Awaited<ReturnType<typeof createContext>>;

    export const handler = awsLambdaRequestHandler({
      router: appRouter,
      createContext,
      responseMeta: ({ errors, ctx }) => {
        // Optional: customize response headers
        const headers: Record<string, string> = {};

        if (errors.length === 0) {
          // Cache successful responses for 1 hour
          headers['Cache-Control'] = 'max-age=3600';
        }

        return { headers };
      },
    });
    ```

  </Tab>
  <Tab value="API Gateway v1">
    ```typescript title="lambda.ts"
    import { 
      CreateAWSLambdaContextOptions, 
      awsLambdaRequestHandler 
    } from '@trpc/server/adapters/aws-lambda';
    import type { APIGatewayProxyEvent } from 'aws-lambda';
    import { appRouter } from './server';

    // Create context for each request
    const createContext = ({
      event,
      context,
    }: CreateAWSLambdaContextOptions<APIGatewayProxyEvent>) => ({
      event,
      context,
      userAgent: event.headers['User-Agent'],
      sourceIp: event.requestContext.identity.sourceIp,
    });

    type Context = Awaited<ReturnType<typeof createContext>>;

    export const handler = awsLambdaRequestHandler({
      router: appRouter,
      createContext,
    });
    ```

  </Tab>
</Tabs>

### 3. Deploy with AWS CDK

```typescript title="infrastructure/api-stack.ts"
import * as cdk from 'aws-cdk-lib';
import * as lambda from 'aws-cdk-lib/aws-lambda';
import * as apigateway from 'aws-cdk-lib/aws-apigateway';
import { NodejsFunction } from 'aws-cdk-lib/aws-lambda-nodejs';

export class ApiStack extends cdk.Stack {
  constructor(scope: Construct, id: string, props?: cdk.StackProps) {
    super(scope, id, props);

    // Lambda function
    const trpcLambda = new NodejsFunction(this, 'TrpcLambda', {
      runtime: lambda.Runtime.NODEJS_18_X,
      entry: 'src/lambda.ts',
      handler: 'handler',
      environment: {
        NODE_ENV: 'production',
      },
    });

    // API Gateway
    const api = new apigateway.RestApi(this, 'TrpcApi', {
      restApiName: 'tRPC API',
      description: 'tRPC serverless API',
    });

    // Proxy all requests to Lambda
    api.root.addProxy({
      defaultIntegration: new apigateway.LambdaIntegration(trpcLambda),
    });

    // Output the API URL
    new cdk.CfnOutput(this, 'ApiUrl', {
      value: api.url,
    });
  }
}
```

### 4. Deploy with Serverless Framework

```yaml title="serverless.yml"
service: trpc-lambda-api

provider:
  name: aws
  runtime: nodejs18.x
  region: us-east-1
  environment:
    NODE_ENV: production

functions:
  trpc:
    handler: dist/lambda.handler
    events:
      - http:
          path: /{proxy+}
          method: ANY
          cors: true

plugins:
  - serverless-plugin-typescript
  - serverless-offline

custom:
  serverless-offline:
    httpPort: 3000
```

## Payload Format Versions

API Gateway has two different event data formats:

<Tabs items={['Version 2.0 (Recommended)', 'Version 1.0 (Legacy)']}>
  <Tab value="Version 2.0 (Recommended)">
    **HTTP APIs** use version 2.0 by default. This is the recommended format for new projects.
    
    ```typescript
    import type { APIGatewayProxyEventV2 } from 'aws-lambda';
    
    const createContext = ({
      event,
      context,
    }: CreateAWSLambdaContextOptions<APIGatewayProxyEventV2>) => ({
      event,
      context,
      requestId: event.requestContext.requestId,
      userAgent: event.headers['user-agent'],
    });
    ```
    
    Features:
    - Simplified event structure
    - Better performance
    - More cost-effective
    - Native JWT authorization support
  </Tab>
  <Tab value="Version 1.0 (Legacy)">
    **REST APIs** use version 1.0. Use this for compatibility with existing infrastructure.
    
    ```typescript
    import type { APIGatewayProxyEvent } from 'aws-lambda';
    
    const createContext = ({
      event,
      context,
    }: CreateAWSLambdaContextOptions<APIGatewayProxyEvent>) => ({
      event,
      context,
      requestId: event.requestContext.requestId,
      userAgent: event.headers['User-Agent'], // Note: different casing
      sourceIp: event.requestContext.identity.sourceIp,
    });
    ```
    
    Features:
    - Full API Gateway REST API features
    - More configuration options
    - Higher cost than HTTP APIs
  </Tab>
</Tabs>

## Lambda Function URLs

Lambda Function URLs provide a simple way to invoke functions over HTTPS without API Gateway:

```typescript title="lambda-url.ts"
import { awsLambdaRequestHandler } from '@trpc/server/adapters/aws-lambda';
import type { APIGatewayProxyEventV2 } from 'aws-lambda';

export const handler = awsLambdaRequestHandler({
  router: appRouter,
  createContext: ({ event, context }) => ({
    event,
    context,
    // Function URLs have simpler event structure
    headers: event.headers,
  }),
});
```

### Deploy with Function URLs

```typescript title="infrastructure/function-url-stack.ts"
import * as lambda from 'aws-cdk-lib/aws-lambda';
import { NodejsFunction } from 'aws-cdk-lib/aws-lambda-nodejs';

const trpcFunction = new NodejsFunction(this, 'TrpcFunction', {
  runtime: lambda.Runtime.NODEJS_18_X,
  entry: 'src/lambda-url.ts',
  handler: 'handler',
});

// Create Function URL
const functionUrl = trpcFunction.addFunctionUrl({
  authType: lambda.FunctionUrlAuthType.NONE, // or AWS_IAM
  cors: {
    allowCredentials: true,
    allowedHeaders: ['Content-Type'],
    allowedMethods: [lambda.HttpMethod.ALL],
    allowedOrigins: ['*'], // Configure appropriately for production
  },
});

new cdk.CfnOutput(this, 'FunctionUrl', {
  value: functionUrl.url,
});
```

## Response Streaming

Lambda Function URLs support response streaming for real-time data:

<Callout title="Streaming Support" type="info">
  Response streaming is only supported with Lambda Function URLs, not API
  Gateway.
</Callout>

```typescript title="streaming-lambda.ts"
import { awsLambdaStreamingRequestHandler } from '@trpc/server/adapters/aws-lambda';
import type { StreamifyHandler } from 'aws-lambda';

const streamingRouter = t.router({
  // Regular procedures work as normal
  getUser: t.procedure
    .input(z.string())
    .query(({ input }) => ({ id: input, name: 'Bilbo' })),

  // Streaming procedure
  streamNumbers: t.procedure.query(async function* () {
    for (let i = 0; i < 10; i++) {
      await new Promise((resolve) => setTimeout(resolve, 500));
      yield { number: i, timestamp: new Date().toISOString() };
    }
  }),
});

// Use streamifyResponse wrapper for streaming
export const handler: StreamifyHandler = awslambda.streamifyResponse(
  awsLambdaStreamingRequestHandler({
    router: streamingRouter,
    createContext: ({ event, context }) => ({ event, context }),
  }),
);
```

## Advanced Configuration

### Error Handling

```typescript title="lambda-with-error-handling.ts"
export const handler = awsLambdaRequestHandler({
  router: appRouter,
  createContext,
  onError: ({ error, path, input, ctx, type }) => {
    // Log errors to CloudWatch
    console.error(`‚ùå tRPC Error on ${type} ${path}:`, {
      error: error.message,
      input,
      stack: error.stack,
      requestId: ctx.event.requestContext.requestId,
    });

    // Send critical errors to monitoring service
    if (error.code === 'INTERNAL_SERVER_ERROR') {
      // await errorService.captureException(error);
    }
  },
});
```

### Authentication with Cognito

```typescript title="auth-context.ts"
import type { APIGatewayProxyEventV2 } from 'aws-lambda';

interface CognitoUser {
  sub: string;
  email: string;
  'cognito:groups': string[];
}

const createContext = ({ event }: CreateAWSLambdaContextOptions<APIGatewayProxyEventV2>) => {
  // Extract user from Cognito JWT claims
  const user = event.requestContext.authorizer?.jwt?.claims as CognitoUser | undefined;

  return {
    event,
    user,
    isAuthenticated: !!user,
    userGroups: user?.['cognito:groups'] || [],
  };
};

// Create authenticated procedure
const authenticatedProcedure = t.procedure.use(({ ctx, next }) => {
  if (!ctx.isAuthenticated) {
    throw new TRPCError({ code: 'UNAUTHORIZED' });
  }
  return next({ ctx: { ...ctx, user: ctx.user! } });
});
```

### Database Integration

```typescript title="db-context.ts"
import { DynamoDBClient } from '@aws-sdk/client-dynamodb';
import { DynamoDBDocumentClient } from '@aws-sdk/lib-dynamodb';

// Create DynamoDB client outside handler for connection reuse
const dynamoClient = new DynamoDBClient({ region: process.env.AWS_REGION });
const docClient = DynamoDBDocumentClient.from(dynamoClient);

const createContext = ({ event, context }: CreateAWSLambdaContextOptions) => ({
  event,
  context,
  db: docClient,
  tableName: process.env.TABLE_NAME!,
});

// Use in procedures
const getUserById = t.procedure
  .input(z.string())
  .query(async ({ input, ctx }) => {
    const result = await ctx.db.send(new GetCommand({
      TableName: ctx.tableName,
      Key: { id: input },
    }));

    return result.Item;
  });
```

## Batching Considerations

<Callout title="Important: httpBatchLink Limitation" type="warn">
  `httpBatchLink`
